<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  

  <title>The Proof - Monad as a Monoid in Category of Endofunctors</title>
  <meta name="description" content="You have probably seen folllowing Definition somewhere on your FP path.

">
  <meta name="author" content="Wojciech Pituła">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="The Proof - Monad as a Monoid in Category of Endofunctors">
  <meta name="twitter:description" content="You have probably seen folllowing Definition somewhere on your FP path.

">
  
  <meta name="twitter:creator" content="Krever01">
  
  <meta name="twitter:image" content="/images/favicons/favicon-194x194.png" />

  <meta property="og:type" content="article">
  <meta property="og:title" content="The Proof - Monad as a Monoid in Category of Endofunctors">
  <meta property="og:description" content="You have probably seen folllowing Definition somewhere on your FP path.

">
  <meta property="og:image" content="/images/favicons/favicon-194x194.png" />

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <link rel="stylesheet" href="/css/main.css?1533221887215690000">
  <link rel="canonical" href="http://w.pitula.me/2016/monad-proof/">
  <link rel="alternate" type="application/rss+xml" title="Wojciech Pituła" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="link to home of Wojciech Pituła">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Wojciech Pituła</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">Heuristically Optimized Person</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="link to Wojciech Pituła blog" class="blog-button">Blog</a></li>
              <li class="navigation__item"><a href="http://w.pitula.me/presentations" title="link to my presentations">Presentations</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">

            
              <!-- Twitter -->
              <li class="navigation__item">
                <a href="http://twitter.com/Krever01" title="@Krever01 on Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>
            

            

            
              <!-- LinkedIn -->
              <li class="navigation__item">
                <a href="https://www.linkedin.com/in/krever" title="krever on LinkedIn" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">LinkedIn</span>
                </a>
              </li>
            

            
              <!-- GitHub -->
              <li class="navigation__item">
                <a href="https://www.github.com/Krever" title="Krever on GitHub" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>
            

            
              <!-- Email -->
              <li class="navigation__item">
                <a href="mailto:w.pitula@gmail.com" title="Email w.pitula@gmail.com" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>
            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-12-11 00:37" class="post-meta__date date">11 Dec 2016</time>
      
      &#8226; <span class="post-meta__tags">on <a href="/tags/#scala">scala</a> <a href="/tags/#category-theory">category-theory</a> </span>
      
    </div>
    <h1 class="post-title">The Proof - Monad as a Monoid in Category of Endofunctors</h1>
  </header>

  <section class="post">
    <p>You have probably seen folllowing <em>Definition</em> somewhere on your FP path.</p>

<blockquote>
  <p>A monad is just a monoid in the category of endofunctors</p>
</blockquote>

<p>If you’re curious, as I am, you’ve probably even googled for some explaination of it. And you probably have found  some answer on SO or Quora… the math answer. So now you know the reasoning but probably your level of understanding have stayed on the exact same level, zero.</p>

<p>In the following post I will try to express this <em>Definition</em> in simple Scala code. Little disclaimer: all of the following code could have been written using scalaz or cats libraries, but for clarity I will stick to the pure Scala.</p>

<h3 id="the-monoid">The Monoid</h3>
<p>I assume you already have some knowledge from category theory, but we will make short remainder here. First, lets define a <code class="highlighter-rouge">Monoid</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">combine</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</code></pre></div></div>
<p>As we can see, it allows us to combine two instances of type <code class="highlighter-rouge">T</code> and gives us zero element, also of type <code class="highlighter-rouge">T</code>. An example may be an <code class="highlighter-rouge">Int</code> with <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">+</code> operation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">IntAddMonoid</span> <span class="k">extends</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">combine</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="the-category">The Category</h2>
<p>Ok, that was the easy part. To go further we need to realize, that <em>Definition</em> speaks about <em>monoid in category of …</em>, so we need to know what it means. In fact what we have defined above is a <em>monoid in category of sets</em> where every type is a set. Lets make it more abstract and start with defining a generic <code class="highlighter-rouge">MonoidalCategory</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonoidalCategory</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Morphism</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">MonoidalProduct</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">G</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">IdentityObject</span>
<span class="o">}</span>
</code></pre></div></div>
<p>I won’t go deep into this, but I hope everything will get much clearer when we define our <code class="highlighter-rouge">CategoryOfSets</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">CategoryOfSets</span> <span class="k">extends</span> <span class="nc">MonoidalCategory</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Morphism</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span> <span class="k">=&gt;</span> <span class="n">G</span>
  <span class="k">type</span> <span class="kt">MonoidalProduct</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">F</span><span class="o">,</span> <span class="n">G</span><span class="o">)</span>
  <span class="k">type</span> <span class="kt">IdentityObject</span> <span class="o">=</span> <span class="nc">Unit</span>
<span class="o">}</span>
</code></pre></div></div>
<p>As we can see, <code class="highlighter-rouge">Morphism</code> is just traditional <code class="highlighter-rouge">Function</code>, that translates object of type <code class="highlighter-rouge">F</code> into object of type <code class="highlighter-rouge">G</code>. <code class="highlighter-rouge">MonoidalPoruct</code> is just a way to combine two elements of category, so in this case we are just making a <code class="highlighter-rouge">Tuple2</code> out of them. For now, we don’t care much for the <code class="highlighter-rouge">IdentityObject</code>, but we can say, that <code class="highlighter-rouge">Unit</code> is an <code class="highlighter-rouge">IndentityObject</code> because <code class="highlighter-rouge">(F, Unit)</code> is equal to <code class="highlighter-rouge">F</code> in terms of possible values it can take.</p>

<h3 id="the-monoid-in-category">The Monoid in Category</h3>
<p>Now we’ve got all the necesseary pieces to define  <code class="highlighter-rouge">MonoidInCategory</code> and <code class="highlighter-rouge">MonoidInCategoryOfSets</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonoidInCategory</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Category</span> <span class="k">&lt;:</span> <span class="kt">MonoidalCategory</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Category</span><span class="k">#</span><span class="kt">Morphism</span><span class="o">[</span><span class="kt">Category</span><span class="k">#</span><span class="kt">IdentityObject</span>, <span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">combine</span><span class="k">:</span> <span class="kt">Category</span><span class="k">#</span><span class="kt">Morphism</span><span class="o">[</span><span class="kt">Category</span><span class="k">#</span><span class="kt">MonoidalProduct</span><span class="o">[</span><span class="kt">T</span>,<span class="kt">T</span><span class="o">]</span>, <span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">MonoidInCategoryOfSets</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MonoidInCategory</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Category</span> <span class="o">=</span> <span class="nc">CategoryOfSets</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="n">T</span>
  <span class="k">def</span> <span class="n">combine</span><span class="k">:</span> <span class="o">((</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">T</span>
<span class="o">}</span>
</code></pre></div></div>
<p>So, our <code class="highlighter-rouge">zero</code> is function from <code class="highlighter-rouge">IdentityObject</code> to <code class="highlighter-rouge">T</code> and our <code class="highlighter-rouge">combine</code> is function from product of <code class="highlighter-rouge">T</code> and <code class="highlighter-rouge">T</code> to another instance of <code class="highlighter-rouge">T</code>.
Can you see that <code class="highlighter-rouge">MonoidInCategoryOfSets</code> is almost the same our firs <code class="highlighter-rouge">Monoid</code>? If not, here is and example for <code class="highlighter-rouge">Int</code> type with add operation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">IntAddMonoidInCategoryOfSets</span> <span class="k">extends</span> <span class="nc">MonoidInCategoryOfSets</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">0</span> 
    <span class="k">def</span> <span class="n">combine</span><span class="k">:</span> <span class="o">((</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">_2</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Not so scary, is it?</p>

<h3 id="the-functor">The Functor</h3>
<p>Now we should define an endofunctor. We will simplify here and use the name <code class="highlighter-rouge">Functor</code> where we should use <code class="highlighter-rouge">EndofunctorInCategoryOfSets</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>
<p>So <code class="highlighter-rouge">F[_]</code> is a <code class="highlighter-rouge">Functor</code> because it is a type constructor(kind <code class="highlighter-rouge">* -&gt; *</code>) and it allows as to lift any function from <code class="highlighter-rouge">A</code> to <code class="highlighter-rouge">B</code> into function from <code class="highlighter-rouge">F[A]</code> to <code class="highlighter-rouge">F[B]</code>.</p>

<h3 id="the-category-of-endofunctors">The Category of Endofunctors</h3>
<p>Now we would probably like to define a <code class="highlighter-rouge">CategoryOfEndofunctors</code> but for this we need few additional steps.That’s because Scala doesn’t provide kind polymorphism, so we cannot put type constructor <code class="highlighter-rouge">F[_]</code>(kind <code class="highlighter-rouge">* -&gt; *</code>) when we require type <code class="highlighter-rouge">F</code>(kind <code class="highlighter-rouge">*</code>).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Product</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">MonoidalCategoryK2</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Morphism</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
  <span class="k">type</span> <span class="kt">MonoidalProduct</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">&lt;:</span> <span class="nc">Product</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">IndentityObject</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Okey, so we migrated our <code class="highlighter-rouge">MonoidalCategory</code> from kind <code class="highlighter-rouge">*</code> into kind <code class="highlighter-rouge">* -&gt; *</code>. One thing that may be not obious here is the <code class="highlighter-rouge">Product</code>. When we were acting in kind <code class="highlighter-rouge">*</code> the product was just a type function(type constructor) from two types into new type, so it was <code class="highlighter-rouge">* -&gt; * -&gt; *</code>, and when aplied with two types(<code class="highlighter-rouge">*</code>), it resulted in type(<code class="highlighter-rouge">*</code>). But now we are acting in world of type constructors(<code class="highlighter-rouge">* -&gt; *</code>) so we need to change <code class="highlighter-rouge">* -&gt; * -&gt; *</code> into <code class="highlighter-rouge">(* -&gt; *) -&gt; (* -&gt; *) -&gt; (* -&gt; *)</code>, so when applied with two type constructors(<code class="highlighter-rouge">* -&gt; *</code>) it will result with type constructor(<code class="highlighter-rouge">* -&gt; *</code>). If it is not clear yet, we’ll have an example soon.
Now lets go back to our mission of defining ` CategoryOfEndofunctors`:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Id</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>

<span class="k">trait</span> <span class="nc">NaturalTransformation</span><span class="o">[</span><span class="kt">-F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">+G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
<span class="k">type</span> <span class="kt">~~&gt;</span><span class="err">[</span><span class="kt">-F</span><span class="o">[</span><span class="k">_</span><span class="o">],</span> <span class="o">+</span><span class="n">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span> <span class="nc">NaturalTransformation</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Compose</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Product</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">G</span><span class="o">]{</span>
  <span class="k">type</span> <span class="kt">Out</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Okey, so we’ve defined three things here. At first we have simple case class that we will use in a moment. Second goes the <code class="highlighter-rouge">NaturalTransformation</code> and it is just a function from <code class="highlighter-rouge">F[T]</code> to <code class="highlighter-rouge">G[T]</code> for any type <code class="highlighter-rouge">T</code>(we also introduce a type alias <code class="highlighter-rouge">~~&gt;</code> that we will use to make things shorter). Then we have an example of a product type that just composes the type constructors. Here is a small example to make it more real:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>
<span class="k">object</span> <span class="nc">TryToOption</span> <span class="k">extends</span> <span class="nc">NaturalTransformation</span><span class="o">[</span><span class="kt">Try</span>, <span class="kt">Option</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">t</span><span class="o">.</span><span class="n">toOption</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">example</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Compose</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">Try</span><span class="o">]</span><span class="k">#</span><span class="nc">Out</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">(</span><span class="nc">Try</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
  <span class="n">result</span>
<span class="o">}</span>
</code></pre></div></div>
<p>And finally, here comes our <code class="highlighter-rouge">CategoryOfEndofunctors</code>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">CategoryOfEndofunctors</span> <span class="k">extends</span> <span class="nc">MonoidalCategoryK2</span><span class="o">{</span>
  <span class="k">type</span> <span class="kt">Morphism</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">NaturalTransformation</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">MonoidalProduct</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Compose</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">G</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">IndentityObject</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Id</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>
<p>As we can see, it’s just assembled with little elements we’ve already definded.</p>

<h3 id="the-monoid-in-category-of-endofunctors">The Monoid in Category of Endofunctors</h3>
<p>As you may feel, we are coming with big steps to the <code class="highlighter-rouge">MonoidInCategoryOfEndofunctors</code> but there is this one thing on our way: we need to migrate <code class="highlighter-rouge">MonoidInCategory</code> from <code class="highlighter-rouge">MonoidalCategory</code> into <code class="highlighter-rouge">MonoidalCategoryK2</code> to make scala compiler happy.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonoidInCategoryK2</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Category</span> <span class="k">&lt;:</span> <span class="kt">MonoidalCategoryK2</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Category</span><span class="k">#</span><span class="kt">Morphism</span><span class="o">[</span><span class="kt">Category</span><span class="k">#</span><span class="kt">IndentityObject</span>, <span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">combine</span><span class="k">:</span> <span class="kt">Category</span><span class="k">#</span><span class="kt">Morphism</span><span class="o">[</span><span class="kt">Category</span><span class="k">#</span><span class="kt">MonoidalProduct</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">T</span><span class="o">]</span><span class="k">#</span><span class="kt">Out</span>, <span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>
<p>And here it comes, THE BIG PLAYER:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonoidInCategoryOfEndofunctors</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">MonoidInCategoryK2</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Category</span> <span class="o">=</span> <span class="nc">CategoryOfEndofunctors</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Id</span> <span class="kt">~~&gt;</span> <span class="kt">F</span>
  <span class="k">def</span> <span class="n">combine</span><span class="k">:</span> <span class="kt">Compose</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">F</span><span class="o">]</span><span class="k">#</span><span class="nc">Out</span> <span class="o">~~&gt;</span> <span class="n">F</span>
  <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Pretty, isn’t it? And not so complicated. Our <code class="highlighter-rouge">zero</code> is now a <code class="highlighter-rouge">NaturalTransformation</code>(instead of a <code class="highlighter-rouge">Function</code>) from <code class="highlighter-rouge">Id</code>(instead of an <code class="highlighter-rouge">Unit</code>) to <code class="highlighter-rouge">F[_]</code>. Our combine is also a <code class="highlighter-rouge">NaturalTransformation</code> from <code class="highlighter-rouge">F[F[_]]</code> to <code class="highlighter-rouge">F[_]</code>. And one more thing, we need an evidence, that <code class="highlighter-rouge">F[_]</code> is a <code class="highlighter-rouge">Functor</code> so we have this little function called <code class="highlighter-rouge">functor</code>.
Maybe a little example of defining such a magnificent beeing?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">OptionMonoid</span> <span class="k">extends</span> <span class="nc">MonoidInCategoryOfEndofunctors</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Id</span> <span class="kt">~~&gt;</span> <span class="kt">Option</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NaturalTransformation</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Option</span><span class="o">]{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">combine</span><span class="k">:</span> <span class="kt">Compose</span><span class="o">[</span><span class="kt">Option</span>,<span class="kt">Option</span><span class="o">]</span><span class="k">#</span><span class="nc">Out</span> <span class="o">~~&gt;</span> <span class="nc">Option</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="nc">NaturalTransformation</span><span class="o">[</span><span class="kt">Compose</span><span class="o">[</span><span class="kt">Option</span>,<span class="kt">Option</span><span class="o">]</span><span class="k">#</span><span class="kt">Out</span>, <span class="kt">Option</span><span class="o">]{</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">opt</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">flatten</span>
    <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">fmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="the-monad">The Monad</h3>
<p>Now, when we have dealt with right side of the equasion, lets got back to the left side. Here is a definition of <code class="highlighter-rouge">Monad</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>
<p>And some example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">OptionMonad</span> <span class="k">extends</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">v</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">m</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="the-proof">The Proof</h2>
<p>If the <em>Definition</em> is true, as the math guys say, we should be able to define following functions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fromMonoidToMonad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">monoid</span><span class="k">:</span> <span class="kt">MonoidInCategoryOfEndofunctors</span><span class="o">[</span><span class="kt">M</span><span class="o">])</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span>
<span class="k">def</span> <span class="n">fromMonadToMonoid</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">MonoidInCategoryOfEndofunctors</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span>
</code></pre></div></div>
<p>and in fact we are! Here is the first one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fromMonoidToMonad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">monoid</span><span class="k">:</span> <span class="kt">MonoidInCategoryOfEndofunctors</span><span class="o">[</span><span class="kt">M</span><span class="o">])</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">new</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">]{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">monoid</span><span class="o">.</span><span class="n">zero</span><span class="o">(</span><span class="nc">Id</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">monoid</span><span class="o">.</span><span class="n">combine</span><span class="o">(</span><span class="n">monoid</span><span class="o">.</span><span class="n">functor</span><span class="o">.</span><span class="n">fmap</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">m</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Pretty short and in fact rather simple. To put value of type <code class="highlighter-rouge">A</code> inside <code class="highlighter-rouge">M[A]</code> it’s enough to put it inside <code class="highlighter-rouge">Id</code> and tranform it with <code class="highlighter-rouge">monoid.zero</code>. To bind value <code class="highlighter-rouge">m</code> of type <code class="highlighter-rouge">M[A]</code> with function <code class="highlighter-rouge">f</code> from <code class="highlighter-rouge">A</code> to <code class="highlighter-rouge">M[B]</code> we can lift <code class="highlighter-rouge">f</code> with <code class="highlighter-rouge">monoid.functor.fmap</code> so now it is <code class="highlighter-rouge">M[A] =&gt; M[M[B]]</code>. Then we apply it with <code class="highlighter-rouge">m</code> and flatten with <code class="highlighter-rouge">monoid.combine</code>. No magic attached.
And the second one, a bit longer I’ve to admit:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fromMonadToMonoid</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonoidInCategoryOfEndofunctors</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">new</span> <span class="nc">MonoidInCategoryOfEndofunctors</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Id</span> <span class="kt">~~&gt;</span> <span class="kt">M</span> <span class="o">=</span> <span class="k">new</span> <span class="o">(</span><span class="nc">Id</span> <span class="o">~~&gt;</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">monad</span><span class="o">.</span><span class="n">unit</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
    <span class="o">}</span>
    
    <span class="k">override</span> <span class="k">def</span> <span class="n">combine</span><span class="k">:</span> <span class="kt">Compose</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">M</span><span class="o">]</span><span class="k">#</span><span class="nc">Out</span> <span class="o">~~&gt;</span> <span class="n">M</span> <span class="k">=</span> <span class="k">new</span> <span class="o">(</span><span class="nc">Compose</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">M</span><span class="o">]</span><span class="k">#</span><span class="nc">Out</span> <span class="o">~~&gt;</span> <span class="n">M</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">monad</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">identity</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
    <span class="o">}</span>
    
    <span class="k">override</span> <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">fmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="n">monad</span><span class="o">.</span><span class="n">bind</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">f</span><span class="o">.</span><span class="n">andThen</span><span class="o">(</span><span class="n">monad</span><span class="o">.</span><span class="n">unit</span><span class="o">))</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Few words of explaination. To transform <code class="highlighter-rouge">a</code>, instance of <code class="highlighter-rouge">Id[A]</code>, into instance of <code class="highlighter-rouge">M[A]</code> we just lift the content of <code class="highlighter-rouge">Id</code> with <code class="highlighter-rouge">monad.unit</code>. To flatten(combine) <code class="highlighter-rouge">M[M[A]]</code> it is enough to bind it with identity functions. To create a <code class="highlighter-rouge">Functor</code> instance, we define <code class="highlighter-rouge">fmap</code> as function that binds it argument with function that is composition of <code class="highlighter-rouge">f</code> and <code class="highlighter-rouge">monad.unit</code>.</p>

<h3 id="the-summary">The summary</h3>
<p>I hope this article was clear enough, and know you understand what this incomprehensible <em>Definition</em> means. Sadly, I don’t have any formal education in field of category theory, but I hope there are no obvious errors. Because all the code attached compiles, I may be sure that the proof is correct as long as defined types are correct.</p>

<p>One thing I have to confess is that I knowingly ignored all aspects of laws.For example <code class="highlighter-rouge">Monad</code> has to obey these three monadic laws, and <code class="highlighter-rouge">Monoid</code> has some laws of his own(just as a <code class="highlighter-rouge">Functor</code> does). You may treat this as a homework, to prove if they hold :)</p>

  </section>
  <section id="disqus_thread"></section><!-- /#disqus_thread -->
</article>

    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://w.pitula.me/2016/monad-proof/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/monad-proof'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
      };

      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//kreverspace.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
       })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2018 Wojciech Pituła. All rights reserved.</span>
</footer>

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1533221887215690000"></script>


    </div>
  </body>
</html>